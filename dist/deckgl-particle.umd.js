var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,n,t)=>n in e?__defProp(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,__spreadValues=(e,n)=>{for(var t in n||(n={}))__hasOwnProp.call(n,t)&&__defNormalProp(e,t,n[t]);if(__getOwnPropSymbols)for(var t of __getOwnPropSymbols(n))__propIsEnum.call(n,t)&&__defNormalProp(e,t,n[t]);return e},__spreadProps=(e,n)=>__defProps(e,__getOwnPropDescs(n));!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@deck.gl/core"),require("@deck.gl/layers"),require("@luma.gl/core")):"function"==typeof define&&define.amd?define(["exports","@deck.gl/core","@deck.gl/layers","@luma.gl/core"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).DeckglParticle={},e.deck,e.deck,e.luma)}(this,(function(e,n,t,o){"use strict";var i=10242,r=10497,s=6371008.8,a={centimeters:637100880,centimetres:637100880,degrees:57.22891354143274,feet:20902260.511392,inches:39.37*s,kilometers:6371.0088,kilometres:6371.0088,meters:s,metres:s,miles:3958.761333810546,millimeters:6371008800,millimetres:6371008800,nauticalmiles:s/1852,radians:1,yards:6967335.223679999};function d(e){return e%360*Math.PI/180}function c(e){if(!e)throw new Error("coord is required");if(!Array.isArray(e)){if("Feature"===e.type&&null!==e.geometry&&"Point"===e.geometry.type)return e.geometry.coordinates;if("Point"===e.type)return e.coordinates}if(Array.isArray(e)&&e.length>=2&&!Array.isArray(e[0])&&!Array.isArray(e[1]))return e;throw new Error("coord must be GeoJSON Point or an Array of numbers")}function u(e,n,t){void 0===t&&(t={});var o=c(e),i=c(n),r=d(i[1]-o[1]),s=d(i[0]-o[0]),u=d(o[1]),l=d(i[1]),p=Math.pow(Math.sin(r/2),2)+Math.pow(Math.sin(s/2),2)*Math.cos(u)*Math.cos(l);return function(e,n){void 0===n&&(n="kilometers");var t=a[n];if(!t)throw new Error(n+" units is invalid");return e*t}(2*Math.atan2(Math.sqrt(p),Math.sqrt(1-p)),t.units)}const l={[i]:r},p=__spreadProps(__spreadValues({},t.LineLayer.defaultProps),{image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[-180,-90,180,90],compare:!0},_imageCoordinateSystem:n.COORDINATE_SYSTEM.LNGLAT,textureParameters:l,numParticles:{type:"number",min:1,max:1e6,value:5e3},maxAge:{type:"number",min:1,max:255,value:100},speedFactor:{type:"number",min:0,max:1,value:1},colors:{type:"object",value:{0:"#3288bd",.1:"#66c2a5",.2:"#abdda4",.3:"#e6f598",.4:"#fee08b",.5:"#fdae61",.6:"#f46d43",1:"#d53e4f"}},width:{type:"number",value:1},uWindMin:{type:"number",value:0},uWindMax:{type:"number",value:0},vWindMin:{type:"number",value:0},vWindMax:{type:"number",value:0},animate:!0,boundsClip:{type:"boolean",value:!1}});class f extends t.LineLayer{getShaders(){return __spreadProps(__spreadValues({},super.getShaders()),{inject:{"vs:#decl":"\n          varying float drop;\n          varying vec2 positionWind;\n          const vec2 DROP_POSITION = vec2(0);\n        ","vs:main":"\n        ","vs:#main-start":"\n          drop = float(instanceSourcePositions.xy == DROP_POSITION || instanceTargetPositions.xy == DROP_POSITION);\n        ","vs:#main-end":"\n          positionWind = instanceTargetPositions.xy;\n        ","fs:#decl":"\n          varying float drop;\n          varying vec2 positionWind;\n          uniform sampler2D uWind;\n          uniform sampler2D colorTexture;\n          uniform vec4 bounds;\n          uniform float uWindMin;\n          uniform float uWindMax;\n          uniform float vWindMin;\n          uniform float vWindMax;\n          vec2 getUV(vec2 pos) {\n            return vec2(\n              (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n              (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n            );\n          }\n        ","fs:#main-start":"\n          if (drop > 0.5) discard;\n        ","fs:#main-end":"\n          vec2 windUV = getUV(positionWind.xy);\n          vec2 windMax = vec2(uWindMax, vWindMax);\n          vec2 windMin = vec2(uWindMin, vWindMin);\n          vec2 velocity = mix(windMin, windMax, texture2D(uWind, windUV).xy);\n          float speed = length(velocity);\n          float maxSpeed = length(windMax);\n          float colorPos = speed / maxSpeed;\n\n          gl_FragColor = vec4(texture2D(colorTexture, vec2(colorPos, 0.)).rgb, gl_FragColor.a);\n        "}})}initializeState(){super.initializeState({}),this._setupTransformFeedback();const e=this.getAttributeManager();null==e||e.remove(["instanceSourcePositions","instanceTargetPositions","instanceColors","instanceWidths"])}updateState({props:e,oldProps:n,changeFlags:t}){super.updateState({props:e,oldProps:n,changeFlags:t}),e.image===n.image&&e.numParticles===n.numParticles&&e.maxAge===n.maxAge&&e.colors===n.colors&&e.width===n.width&&e.uWindMin===n.uWindMin&&e.uWindMax===n.uWindMax&&e.vWindMin===n.vWindMin&&e.vWindMax===n.vWindMax||this._setupTransformFeedback()}finalizeState(){this._deleteTransformFeedback(),super.finalizeState()}draw({uniforms:e}){const{animate:n,image:t,bounds:o,uWindMin:i,uWindMax:r,vWindMin:s,vWindMax:a}=this.props,{sourcePositions:d,targetPositions:c,sourcePositions64Low:u,targetPositions64Low:l,widths:p,model:f,colorTexture:m,instanceColors:v}=this.state;n&&this._runTransformFeedback(),f.setAttributes({instanceSourcePositions:d,instanceTargetPositions:c,instanceSourcePositions64Low:u,instanceTargetPositions64Low:l,instanceColors:v,instanceWidths:p}),f.setUniforms({uWind:t,colorTexture:m,bounds:o,uWindMin:i,uWindMax:r,vWindMin:s,vWindMax:a}),super.draw({uniforms:e}),this.setNeedsRedraw()}_setupTransformFeedback(){const{gl:e}=this.context,{numParticles:n,maxAge:t,colors:i,width:r}=this.props,{initialized:s}=this.state;s&&this._deleteTransformFeedback();const a=n*t,d=n*(t-1),c=new o.Buffer(e,new Float32Array(3*a)),u=new o.Buffer(e,new Float32Array(3*a)),l=new Float32Array([0,0,0]),p=new Float32Array([0,0,0]),f=new o.Buffer(e,new Float32Array(new Array(a).fill(void 0).map(((e,o)=>[255,255,255,255*(1-Math.floor(o/n)/t)].map((e=>e/255)))).flat())),m=new Float32Array([r]),v=new o.Transform(e,{sourceBuffers:{sourcePosition:c},feedbackBuffers:{targetPosition:u},feedbackMap:{sourcePosition:"targetPosition"},vs:"#version 300 es\n#define SHADER_NAME particle-layer-update-transform-vertex-shader\n\nprecision highp float;\n\nin vec3 sourcePosition;\nout vec3 targetPosition;\n\nuniform sampler2D speedTexture;\nuniform vec4 bounds;\n\nuniform float numParticles;\nuniform float maxAge;\n\nuniform float viewportSphere;\nuniform vec2 viewportSphereCenter;\nuniform float viewportSphereRadius;\nuniform vec4 viewportBounds;\nuniform float viewportSpeedFactor;\n\nuniform float time;\nuniform float seed;\n\nconst vec2 DROP_POSITION = vec2(0);\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\nvec4 clipBox(vec4 bbox1, vec4 bbox2) {\n    return vec4(\n        max(bbox1[0], bbox2[0]),\n        max(bbox1[1], bbox2[1]),\n        min(bbox1[2], bbox2[2]),\n        min(bbox1[3], bbox2[3])\n    );\n}\n\n// see https://stackoverflow.com/a/27228836/1823988\nfloat atan2(float y, float x) {\n  return x == 0. ? sign(y) * PI / 2. : atan(y, x);\n}\n\n// see https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js#L187\nfloat distanceTo(vec2 from, vec2 point) {\n  float y1 = radians(from.y);\n  float x1 = radians(from.x);\n  float y2 = radians(point.y);\n  float x2 = radians(point.x);\n  float dy = y2 - y1;\n  float dx = x2 - x1;\n\n  float a = sin(dy / 2.) * sin(dy / 2.) + cos(y1) * cos(y2) * sin(dx / 2.) * sin(dx / 2.);\n  float c = 2. * atan2(sqrt(a), sqrt(1. - a));\n  float d = EARTH_RADIUS * c;\n\n  return d;\n}\n\n// see https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js#L360\nvec2 destinationPoint(vec2 from, float dist, float bearing) {\n  float d = dist / EARTH_RADIUS;\n  float r = radians(bearing);\n\n  float y1 = radians(from.y);\n  float x1 = radians(from.x);\n\n  float siny2 = sin(y1) * cos(d) + cos(y1) * sin(d) * cos(r);\n  float y2 = asin(siny2);\n  float y = sin(r) * sin(d) * cos(y1);\n  float x = cos(d) - sin(y1) * siny2;\n  float x2 = x1 + atan2(y, x);\n\n  float lat = degrees(y2);\n  float lon = degrees(x2);\n\n  return vec2(lon, lat);\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 randVec2(vec2 seed) {\n  return vec2(rand(seed + 1.3), rand(seed + 2.1));\n}\n\nvec2 randPosition(vec2 seed) {\n  vec2 randomVec2 = randVec2(seed);\n  \n  if (viewportSphere > 0.5) {\n    randomVec2.x += 0.0001; // prevent generating point in the center\n    float dist = sqrt(randomVec2.x) * viewportSphereRadius;\n    float bearing = randomVec2.y * 360.;\n    return destinationPoint(viewportSphereCenter, dist, bearing);\n  } else {\n    vec2 viewportBoundsMin = viewportBounds.xy;\n    vec2 viewportBoundsMax = viewportBounds.zw;\n    return mix(viewportBoundsMin, viewportBoundsMax, randomVec2);\n  }\n}\n\nbool isPositionVisible(vec2 position) {\n  if (viewportSphere > 0.5) {\n    return distanceTo(viewportSphereCenter, position) <= viewportSphereRadius;\n  } else {\n    vec2 viewportBoundsMin = viewportBounds.xy;\n    vec2 viewportBoundsMax = viewportBounds.zw;\n    return (\n      viewportBoundsMin.x <= position.x && position.x <= viewportBoundsMax.x &&\n      viewportBoundsMin.y <= position.y && position.y <= viewportBoundsMax.y\n    );\n  }\n}\n\nvoid main() {\n  float particleIndex = mod(float(gl_VertexID), numParticles);\n  float particleAge = floor(float(gl_VertexID) / numParticles);\n\n  if (sourcePosition.xy != DROP_POSITION) {\n    // update position\n    vec2 uv = getUV(sourcePosition.xy);\n    vec4 values = texture2D(speedTexture, uv);\n    vec2 speed = values.xy * 2. - 1.;\n    // float dist = sqrt(speed.x * speed.x + speed.y + speed.y) * viewportSpeedFactor * 10000.;\n    // float bearing = degrees(-atan2(speed.y, speed.x));\n    // targetPosition.xy = destinationPoint(sourcePosition.xy, dist, bearing);\n    float distortion = cos(radians(sourcePosition.y)); \n    vec2 distortedSpeed = vec2(speed.x / distortion, speed.y);\n    vec2 offset = distortedSpeed * viewportSpeedFactor;\n    targetPosition.xy = sourcePosition.xy + offset;\n\n    if (values.a != 1.) {\n      // drop nodata\n      targetPosition.xy = DROP_POSITION;\n    }\n\n    // drop out of bounds\n    if (!isPositionVisible(sourcePosition.xy) || !isPositionVisible(targetPosition.xy)) {\n      targetPosition.xy = DROP_POSITION;\n    }\n\n    if (particleAge < 1.) {\n      if (abs(mod(particleIndex, maxAge + 2.) - mod(time, maxAge + 2.)) < 1.) {\n        // drop by maxAge, +2 because only non-randomized pairs are rendered\n        targetPosition.xy = DROP_POSITION;\n      }\n    }\n  } else {\n    if (particleAge < 1.) {\n      // generate random position to prevent converging particles\n      vec2 randomSeed = vec2(particleIndex * seed / numParticles);\n      vec2 randomPosition = randPosition(randomSeed);\n      targetPosition.xy = randomPosition;\n    } else {\n      targetPosition.xy = DROP_POSITION;\n    }\n  }\n}\n",elementCount:a}),x=new o.Texture2D(e,{data:this.getColorRamp(i)});this.setState({initialized:!0,numInstances:a,numAgedInstances:d,sourcePositions:c,targetPositions:u,sourcePositions64Low:l,targetPositions64Low:p,instanceColors:f,widths:m,transform:v,colorTexture:x})}_runTransformFeedback(){const{viewport:e,timeline:n}=this.context,{image:t,bounds:o,numParticles:i,speedFactor:r,maxAge:s,boundsClip:a}=this.props,{numAgedInstances:d,transform:c}=this.state;if(!t)return;const l=e.resolution?1:0,p=[e.longitude,e.latitude],f=Math.max(u(p,e.unproject([0,0]),{units:"meters"}),u(p,e.unproject([e.width/2,0]),{units:"meters"}),u(p,e.unproject([0,e.height/2]),{units:"meters"})),m=e.getBounds();m[1]=Math.max(m[1],-85.051129),m[3]=Math.min(m[3],85.051129);const v=r*window.devicePixelRatio/2**e.zoom,x=c.bufferTransform.bindings[c.bufferTransform.currentIndex].sourceBuffers.sourcePosition,y=c.bufferTransform.bindings[c.bufferTransform.currentIndex].feedbackBuffers.targetPosition;x.copyData({sourceBuffer:y,readOffset:0,writeOffset:4*i*3,size:4*d*3});const g={speedTexture:t,bounds:o,numParticles:i,maxAge:s,viewportSphere:l,viewportSphereCenter:p,viewportSphereRadius:f,viewportBounds:a?(P=m,b=o,[Math.max(P[0],b[0]),Math.max(P[1],b[1]),Math.min(P[2],b[2]),Math.min(P[3],b[3])]):m,viewportSpeedFactor:v,time:n.getTime(),seed:Math.random()};var P,b;c.run({uniforms:g}),c.swap()}_deleteTransformFeedback(){const{initialized:e,sourcePositions:n,targetPositions:t,instanceColors:o,transform:i}=this.state;e&&(n.delete(),t.delete(),o.delete(),i.delete(),this.setState({initialized:!1,sourcePositions:void 0,targetPositions:void 0,sourcePositions64Low:void 0,targetPositions64Low:void 0,instanceColors:void 0,widths:void 0,transform:void 0,colorTexture:void 0}))}step(){this._runTransformFeedback(),this.setNeedsRedraw()}clear(){const{numInstances:e,sourcePositions:n,targetPositions:t}=this.state;n.subData({data:new Float32Array(3*e)}),t.subData({data:new Float32Array(3*e)}),this.setNeedsRedraw()}getColorRamp(e){const n=document.createElement("canvas"),t=n.getContext("2d");n.width=256,n.height=1;const o=t.createLinearGradient(0,0,256,0);for(const i in e)o.addColorStop(+i,e[i]);return t.fillStyle=o,t.fillRect(0,0,256,1),n.toDataURL()}}f.layerName="ParticleLayer",f.defaultProps=p,e.ParticleLayer=f,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
